# -*- coding: utf-8 -*-
"""db3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wc3K5GX-ezhFdZkWH34vIKVMOenRHnoa
"""

# -*- coding: utf-8 -*-
"""db3.ipynb

Automatically generated by Colab.

"""

import streamlit as st
import pandas as pd
import matplotlib.pyplot as plt
import plotly.express as px
import pydeck as pdk
import seaborn as sns
from sklearn.cluster import KMeans
from sklearn.ensemble import RandomForestRegressor

# -------------------------------
# Custom Styling
# -------------------------------
import base64

def apply_custom_css():
    st.markdown("""
        <style>
        [data-testid="stSidebar"] {
            background-color: #f5f5f5;
        }
        .stApp h1, h2, h3 {
            color: #4B0082;
            font-family: 'Segoe UI', sans-serif;
        }
        .stButton>button {
            background-color: #6a0dad;
            color: white;
            border-radius: 8px;
            padding: 0.4em 1em;
            font-weight: bold;
        }
        .stTextInput input, .stSelectbox div, .stMultiSelect div {
            border-radius: 6px !important;
        }
        .stDataFrame {
            border: 1px solid #dee2e6;
            border-radius: 6px;
        }
        .stApp {
            background-color: #fcfcfc;
        }
        footer {visibility: hidden;}
        </style>
    """, unsafe_allow_html=True)

# -------------------------------
# Data Loader
# -------------------------------
@st.cache_data
def load_data():
    df = pd.read_csv("AB_NYC_2019.csv")
    df.dropna(subset=["latitude", "longitude"], inplace=True)
    return df

# -------------------------------
# EDA
# -------------------------------
def run_eda(df):
    st.subheader("üîç Enhanced Data Exploration")
    search = st.text_input("Search by host name")
    exact_match = st.checkbox("Match only exact host name", value=False)

    if search:
        df["host_name"] = df["host_name"].fillna("")
        if exact_match:
            df = df[df["host_name"].str.lower() == search.lower()]
        else:
            df = df[df["host_name"].str.contains(search, case=False, na=False)]

    neighborhood = st.multiselect("Filter by neighborhood group", df["neighbourhood_group"].unique())
    if neighborhood:
        df = df[df["neighbourhood_group"].isin(neighborhood)]

    show_cols = st.multiselect("Select columns to display", df.columns.tolist(), default=df.columns.tolist())
    st.dataframe(df[show_cols])

# -------------------------------
# Visualizations
# -------------------------------
def run_visualizations(df):
    st.subheader("üìç Listing Heatmap")

    # Drop rows with missing coordinates
    df = df.dropna(subset=["latitude", "longitude"])

    # Convert to numeric just to be safe
    df["latitude"] = pd.to_numeric(df["latitude"], errors="coerce")
    df["longitude"] = pd.to_numeric(df["longitude"], errors="coerce")

    midpoint = (df["latitude"].mean(), df["longitude"].mean())

    # Show map using ScatterplotLayer for better marker clarity
    st.pydeck_chart(pdk.Deck(
        map_style="mapbox://styles/mapbox/light-v9",
        initial_view_state=pdk.ViewState(
            latitude=midpoint[0],
            longitude=midpoint[1],
            zoom=10,
            pitch=45
        ),
        layers=[
            pdk.Layer(
                "ScatterplotLayer",
                data=df,
                get_position='[longitude, latitude]',
                get_color='[200, 30, 0, 160]',
                get_radius=100,
                pickable=True,
            )
        ],
        tooltip={"text": "Price: ${price}\nNeighborhood: {neighbourhood}"}
    ))

    # Time trend of reviews
    if "last_review" in df.columns:
        df['last_review'] = pd.to_datetime(df['last_review'], errors='coerce')
        df = df.dropna(subset=['last_review'])

        st.subheader("üìà Listings Over Time")
        monthly = df['last_review'].dt.to_period("M").value_counts().sort_index()
        fig, ax = plt.subplots(figsize=(10, 4))
        monthly.plot(kind='line', ax=ax, marker='o', color='mediumblue')
        ax.set_ylabel("Number of Reviews")
        ax.set_title("Monthly Review Count")
        st.pyplot(fig)

    # Top listings by price
    st.subheader("üí∞ Top 10 Listings by Price")
    top10 = df.nlargest(10, "price")[["name", "host_name", "neighbourhood", "price"]]
    st.dataframe(top10)

# -------------------------------
# Clustering
# -------------------------------
import plotly.express as px
from sklearn.cluster import KMeans

def run_clustering(df):
    st.subheader("üß≠ Listing Clusters (K-Means)")

    # Filter and clean
    df_clean = df[["latitude", "longitude", "price", "neighbourhood_group", "room_type"]].dropna()
    df_clean = df_clean[df_clean["price"] < 500]  # Remove outliers

    # Select number of clusters
    k = st.slider("Choose number of clusters (K)", min_value=2, max_value=10, value=4)

    # Fit KMeans
    kmeans = KMeans(n_clusters=k, random_state=42)
    df_clean["cluster"] = kmeans.fit_predict(df_clean[["latitude", "longitude", "price"]])

    # Show summary
    st.markdown("### üìä Cluster Summary")
    cluster_summary = df_clean.groupby("cluster")[["price"]].agg(["count", "mean", "median"]).reset_index()
    cluster_summary.columns = ["Cluster", "Listings", "Avg Price", "Median Price"]
    st.dataframe(cluster_summary)

    # Plot map
    st.markdown("### üåç Cluster Visualization on Map")
    fig = px.scatter_mapbox(
        df_clean,
        lat="latitude",
        lon="longitude",
        color="cluster",
        hover_data=["price", "neighbourhood_group", "room_type"],
        zoom=10,
        mapbox_style="carto-positron",
        height=600
    )
    st.plotly_chart(fig, use_container_width=True)

# -------------------------------
# Price Estimator
# -------------------------------
def run_price_estimator(df):
    st.subheader("üí≤ Price Estimator")
    df = df[["room_type", "minimum_nights", "number_of_reviews", "availability_365", "price"]].dropna()
    df = df[df["price"] < 500]
    df = pd.get_dummies(df, drop_first=True)
    X = df.drop("price", axis=1)
    y = df["price"]
    model = RandomForestRegressor().fit(X, y)

    room = st.selectbox("Room Type", [col for col in X.columns if "room_type_" in col])
    nights = st.slider("Minimum Nights", 1, 30, 2)
    reviews = st.slider("Number of Reviews", 0, 200, 10)
    avail = st.slider("Availability per Year", 0, 365, 180)

    input_df = pd.DataFrame([[nights, reviews, avail] + [1 if col == room else 0 for col in X.columns[3:]]], columns=X.columns)
    price_pred = model.predict(input_df)[0]
    st.success(f"Estimated Price per Night: ${price_pred:.2f}")

# -------------------------------
# Neighborhood Insights
# -------------------------------

def run_neighborhood_insights(df):
    st.subheader("üèòÔ∏è Neighborhood & Room Type Insights")

    # Filter out extreme price outliers for better visuals
    df = df[df["price"] < 500]

    st.markdown("### üí∞ Average Price by Neighborhood Group")
    avg_price = df.groupby("neighbourhood_group")["price"].mean().reset_index()
    fig1 = px.bar(
        avg_price,
        x="neighbourhood_group",
        y="price",
        color="neighbourhood_group",
        title="üíµ Average Price by Neighborhood Group",
        labels={"price": "Average Price", "neighbourhood_group": "Neighborhood"},
        height=400
    )
    st.plotly_chart(fig1, use_container_width=True)

    st.markdown("### üõèÔ∏è Room Type Distribution")
    room_type_dist = df["room_type"].value_counts().reset_index()
    room_type_dist.columns = ["room_type", "count"]
    fig2 = px.bar(
        room_type_dist,
        x="room_type",
        y="count",
        color="room_type",
        title="üõèÔ∏è Room Type Frequency",
        labels={"room_type": "Room Type", "count": "Listing Count"},
        height=400
    )
    st.plotly_chart(fig2, use_container_width=True)

    st.markdown("### üìä Price Distribution by Room Type")
    fig3 = px.box(
        df,
        x="room_type",
        y="price",
        color="room_type",
        title="üìà Price Spread by Room Type",
        labels={"room_type": "Room Type", "price": "Price (USD)"},
        height=500
    )
    st.plotly_chart(fig3, use_container_width=True)

    st.markdown("### üîç Filter and View Listings by Group + Room Type")
    group = st.selectbox("Select Neighborhood Group", df["neighbourhood_group"].unique())
    room = st.selectbox("Select Room Type", df["room_type"].unique())
    filtered = df[(df["neighbourhood_group"] == group) & (df["room_type"] == room)]

    top_listings = filtered.sort_values("price", ascending=False)[["name", "neighbourhood", "price", "number_of_reviews"]].head(10)
    st.dataframe(top_listings)

# -------------------------------
# Main App
# -------------------------------
def main():
    st.set_page_config(layout="wide", page_title="NYC Airbnb Dashboard")
    st.title("üèôÔ∏è NYC Airbnb Open Data Analysis")

    apply_custom_css()

    st.sidebar.title("üß≠ Navigation")
    st.sidebar.markdown("Explore various insights from NYC Airbnb listings.")

    menu = st.sidebar.radio(
        "Select a Section",
        [
            "üîç Explore Data",
            "üìä Visualizations",
            "üß≠ Clustering",
            "üîÆ Price Prediction",
            "üèòÔ∏è Neighborhood Insights"
        ]
    )

    data = load_data()

    if menu == "üîç Explore Data":
        st.markdown("Use filters to search by host name and neighborhood group. Ideal for quick inspection of raw Airbnb listings.")
        run_eda(data)

    elif menu == "üìä Visualizations":
        st.markdown("View geographical heatmaps, review trends, and top listings by price.")
        run_visualizations(data)

    elif menu == "üß≠ Clustering":
        st.markdown("Apply K-Means clustering to group listings by location and price. Great for segmentation and hotspot discovery.")
        run_clustering(data)

    elif menu == "üîÆ Price Prediction":
        st.markdown("Estimate listing price based on room type, availability, and other parameters using machine learning.")
        run_price_estimator(data)

    elif menu == "üèòÔ∏è Neighborhood Insights":
        st.markdown("Compare average prices and room types across neighborhoods. Identify the best-performing areas.")
        run_neighborhood_insights(data)

if __name__ == "__main__":
    main()